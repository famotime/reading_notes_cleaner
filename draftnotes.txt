Python编程：从入门到实践
1.2　在不同操作系统中搭建Python编程环境
2019-07-06
长期以来，编程界都认为刚接触一门新语言时，如果首先使用它来编写一个在屏幕上显示消息“Hello world!”的程序，将给你带来好运。
2.2.2　使用变量时避免命名错误
2019-07-09
变量名只能包含字母、数字和下划线。变量名可以字母或下划线打头，但不能以数字打头，
2019-07-09
变量名不能包含空格，但可使用下划线来分隔其中的单词
2019-07-09
慎用小写字母l和大写字母O，因为它们可能被人错看成数字1和0。
2.3　字符串
2019-07-09
应使用小写的Python变量名。
2.3.2　合并（拼接）字符串
2019-07-09
对于字符串，可执行的最简单的操作之一是修改其中的单词的大小写
2019-07-09
name = "ada lovelace"
print(name.title())
2019-07-09
，name 后面的句点（. ）让Python对变量name 执行方法title() 指定的操作
2019-07-09
title() 以首字母大写的方式显示每个单词，即将每个单词的首字母都改为大写。
2019-07-09
name = "Ada Lovelace"
print(name.upper())print(name.lower())
2.3.3　使用制表符或换行符来添加空白
2019-07-09
存储数据时，方法lower() 很有用。很多时候，你无法依靠用户来提供正确的大小写，因此需要将字符串先转换为小写，再存储它们。以后需要显示这些信息时，再将其转换为最合适的大小写方式。
2019-07-09
Python使用加号（+ ）来合并字符串
2.3.4　删除空白
2019-07-09
message = "Hello, " + full_name.title() + "!"
❷ print(message)
2019-07-09
上述代码也显示消息“Hello, Ada Lovelace!”，但将这条消息存储在了一个变量中（见❶），这让最后的print 语句简单得多（见❷）。
2.3.5　使用字符串时避免语法错误
2019-07-09
Python能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法rstrip() 。
2019-07-09
要永久删除这个字符串中的空白，必须将删除操作的结果存回到变量中：
2019-07-09
>>> favorite_language = 'python '
❶ >>> favorite_language = favorite_language.rstrip() >>> favorite_language
'python'
2019-07-09
在编程中，经常需要修改变量的值，再将新值存回到原来的变量中。这就是变量的值可能随程序的运行或用户输入数据而发生变化的原因。
2019-07-09
你还可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法lstrip() 和strip() ：
2.3.6　Python 2中的print语句
2019-07-09
在实际程序中，这些剥除函数最常用于在存储用户输入前对其进行清理。
2.4　数字
2019-07-09
动手
2.5　注释
2019-07-09
计算整数结果时，采取的方式不是四舍五入，而是将小数部分直接删除。
2.7　小结
2019-07-09
要获悉这些有关编写优秀Python代码的指导原则，只需在解释器中执行命令import this
3.1.1　访问列表元素
2019-07-09
鉴于列表通常包含多个元素，给列表指定一个表示复数的名称（如letters 、digits 或names ）是个不错的主意。
3.3　组织列表
2019-07-09
如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del 语句；如果你要在删除元素后还能继续使用它，就使用方法pop() 。
2019-07-09
方法remove() 只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值
3.4　使用列表时避免索引错误
2019-07-09
在你需要完成如下任务时，len() 很有用：确定还有多少个外星人未被射杀，需要管理多少项可视化数据，网站有多少注册用户等。
3.5　小结
2019-07-09
发生索引错误却找不到解决办法时，请尝试将列表或其长度打印出来。列表可能与你以为的截然不同，在程序对其进行了动态处理时尤其如此。通过查看列表或其包含的元素数，可帮助你找出这种逻辑错误。
4.1.3　在for循环结束后执行一些操作
2019-07-09
每个缩进的代码行都是循环的一部分，且将针对列表中的每个值都执行一次
4.2.1　忘记缩进
2019-07-09
Python根据缩进来判断代码行与前一个代码行的关系
4.3　创建数值列表
2019-07-09
for 语句末尾的冒号告诉Python，下一行是循环的第一行。
4.3.3　对数字列表执行简单的统计计算
2019-07-09
如何创建一个列表，其中包含前10个整数（即1~10）的平方呢？在Python中，两个星号（** ）表示乘方运算。下面的代码演示了如何将前10个整数的平方加入到一个列表中：
squares.py
❶ squares = []❷ for value in range(1,11):
❸ square = value**2❹ squares.append(square)
2019-07-09
为让这些代码更简洁，可不使用临时变量square ，而直接将每个计算得到的值附加到列表末尾：
2019-07-09
squares = []
for value in range(1,11):❶ squares.append(value**2)
print(squares)
4.3.4　列表解析
2019-07-09
有时候，使用临时变量会让代码更易读；而在其他情况下，这样做只会让代码无谓地变长。你首先应该考虑的是，编写清晰易懂且能完成所需功能的代码；等到审核代码时，再考虑采用更高效的方法。
4.4　使用列表的一部分
2019-07-09
下面的示例使用列表解析创建你在前面看到的平方数列表：
squares.py
squares = [value**2 for value in range(1,11)]print(squares)
2019-07-09
要使用这种语法，首先指定一个描述性的列表名，如squares ；然后，指定一个左方括号，并定义一个表达式，用于生成你要存储到列表中的值。在这个示例中，表达式为value**2 ，它计算平方值。接下来，编写一个for 循环，用于给表达式提供值，再加上右方括号。在这个示例中，for 循环为for value in range(1,11) ，它将值1~10提供给表达式value**2 。请注意，这里的for 语句末尾没有冒号。
4.5　元组
2019-07-09
要复制列表，可创建一个包含整个列表的切片，方法是同时省略起始索引和终止索引（[:] ）。这让Python创建一个始于第一个元素，终止于最后一个元素的切片，即复制整个列表。
2019-07-09
my_foods = ['pizza', 'falafel', 'carrot cake']
❷ friend_foods = my_foods[:]
2019-07-09
#这行不通
❶ friend_foods = my_foods
2019-07-09
这里将my_foods 赋给friend_foods ，而不是将my_foods 的副本存储到friend_foods （见❶）。这种语法实际上是让Python将新变量friend_foods 关联到包含在my_foods 中的列表，因此这两个变量都指向同一个列表。
4.5.2　遍历元组中的所有值
2019-07-09
Python将不能修改的值称为不可变的 ，而不可变的列表被称为元组 。
2019-07-09
元组看起来犹如列表，但使用圆括号而不是方括号来标识。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样。
4.6　设置代码格式
2019-07-09
虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺寸，可重新定义整个元组：
4.6.4　空行
2019-07-09
很多Python程序员都建议每行不超过80字符。最初制定这样的指南时，在大多数计算机中，终端窗口每行只能容纳79字符；当前，计算机屏幕每行可容纳的字符数多得多，为何还要使用79字符的标准行长呢？这里有别的原因。专业程序员通常会在同一个屏幕上打开多个文件，使用标准行长可以让他们在屏幕上并排打开两三个文件时能同时看到各个文件的完整行。
2019-07-09
在大多数编辑器中，都可设置一个视觉标志——通常是一条竖线，让你知道不能越过的界线在什么地方。
5.2.2　检查是否相等时不考虑大小写
2019-07-09
一个等号是陈述；对于❶处的代码，可解读为“将变量car 的值设置为'audi' ”。两个等号是发问；对于❷处的代码，可解读为“变量car 的值是'bmw' 吗？”
5.3.5　省略else代码块
2019-07-09
可根据需要使用任意数量的elif 代码块
5.4.1　检查特殊元素
2019-07-09
else 是一条包罗万象的语句，只要不满足任何if 或elif 中的条件测试，其中的代码就会执行，这可能会引入无效甚至恶意的数据。如果知道最终要测试的条件，应考虑使用一个elif 代码块来代替else 代码块。这样，你就可以肯定，仅当满足相应的条件时，你的代码才会执行。
2019-07-09
if-elif-else 结构功能强大，但仅适合用于只有一个条件满足的情况：遇到通过了的测试后，Python就跳过余下的测试。这种行为很好，效率很高，让你能够测试一个特定的条件。
然而，有时候必须检查你关心的所有条件。在这种情况下，应使用一系列不包含elif 和else 代码块的简单if 语句。在可能有多个条件为True ，且你需要在每个条件为True 时都采取相应措施时，适合使用这种方法。
2019-07-09
总之，如果你只想执行一个代码块，就使用if-elif-else 结构；如果要运行多个代码块，就使用一系列独立的if 语句。
5.4.3　使用多个列表
2019-07-09
requested_toppings = []
❷ if requested_toppings:
for requested_topping in requested_toppings: print("Adding " + requested_topping + ".")
print("\nFinished making your pizza!")❸ else:
print("Are you sure you want a plain pizza?")
2019-07-09
在if 语句中将列表名用在条件表达式中时，Python将在列表至少包含一个元素时返回True ，并在列表为空时返回False 。如果requested_toppings 不为空，就运行与前一个示例相同的for 循环；否则，就打印一条消息，询问顾客是否确实要点不加任何配料的普通比萨（见❸）。
6.3.1　遍历所有的键—值对
2019-07-10
我们将一个较大的字典放在了多行中。
2019-07-10
❶ print("Sarah's favorite language is " +
❷ favorite_languages['sarah'].title() +❸ ".")
2019-07-10
这个示例还演示了如何将较长的print 语句分成多行。单词print 比大多数字典名都短，因此让输出的第一部分紧跟在左括号后面是合理的（见❶）。请选择在合适的地方拆分要打印的内容，并在第一行末尾（见❷）加上一个拼接运算符（+ ）。按回车键进入print 语句的后续各行，并使用Tab键将它们对齐并缩进一级。指定要打印的所有内容后，在print 语句的最后一行末尾加上右括号（见❸）。
6.3.2　遍历字典中的所有键
2019-07-10
❶ for key, value in user_0.items():
❷ print("\nKey: " + key)❸ print("Value: " + value)
2019-07-10
如❶所示，要编写用于遍历字典的for 循环，可声明两个变量，用于存储键—值对中的键和值。对于这两个变量，可使用任何名称。下面的代码使用了简单的变量名，这完全可行：
2019-07-10
for k, v in user_0.items()
2019-07-10
注意，即便遍历字典时，键—值对的返回顺序也与存储顺序不同。Python不关心键—值对的存储顺序，而只跟踪键和值之间的关联关系。
6.4.1　字典列表
2019-07-10
为剔除重复项，可使用集合（set）。集合 类似于列表，但每个元素都必须是独一无二的：
6.4.2　在字典中存储列表
2019-07-10
alien_0 = {'color': 'green', 'points': 5}
alien_1 = {'color': 'yellow', 'points': 10} alien_2 = {'color': 'red', 'points': 15}
❶ aliens = [alien_0, alien_1, alien_2]
2019-07-10
我们首先创建了三个字典，其中每个字典都表示一个外星人。在❶处，我们将这些字典都放到一个名为aliens 的列表中
2019-07-10
更符合现实的情形是，外星人不止三个，且每个外星人都是使用代码自动生成的。在下面的示例中，我们使用range() 生成了30个外星人：
2019-07-10
# 创建一个用于存储外星人的空列表
aliens = []
# 创建30个绿色的外星人❶ for alien_number in range(30):
❷ new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}❸ aliens.append(new_alien)
# 显示前五个外星人
❹ for alien in aliens[:5]: print(alien)
print("...")
6.4.3　在字典中存储字典
2019-07-10
有时候，需要将列表存储在字典中，而不是将字典存储在列表中。例如，你如何描述顾客点的比萨呢？如果使用列表，只能存储要添加的比萨配料；但如果使用字典，就不仅可在其中包含配料列表，还可包含其他有关比萨的描述。
在下面的示例中，存储了比萨的两方面信息：外皮类型和配料列表。其中的配料列表是一个与键'toppings' 相关联的值。要访问该列表，我们使用字典名和键'toppings' ，就像访问字典中的其他值一样。这将返回一个配料列表，而不是单个值：
2019-07-10
❶ pizza = {
'crust': 'thick', 'toppings': ['mushrooms', 'extra cheese'],
}
2019-07-10
每当需要在字典中将一个键关联到多个值时，都可以在字典中嵌套一个列表。
2019-07-10
因此，在遍历该字典的for 循环中，我们需要再使用一个for 循环来遍历与被调查者相关联的语言列表：
6.5　小结
2019-07-10
注意 　列表和字典的嵌套层级不应太多。如果嵌套层级比前面的示例多得多，很可能有更简单的解决问题的方案。
2019-07-10
可在字典中嵌套字典，但这样做时，代码可能很快复杂起来。
7.1.1　编写清晰的程序
2019-07-10
你需要使用while 循环让程序不断地运行，直到指定的条件不满足为止。
7.1.2　使用int()来获取数值输入
2019-07-10
注意 　Sublime Text不能运行提示用户输入的程序。你可以使用Sublime Text来编写提示用户输入的程序，但必须从终端运行它们。
2019-07-10
有时候，提示可能超过一行，例如，你可能需要指出获取特定输入的原因。在这种情况下，可将提示存储在一个变量中，再将该变量传递给函数input() 。这样，即便提示超过一行，input() 语句也非常清晰。
2019-07-10
prompt = "If you tell us who you are, we can personalize the messages you see."
prompt += "\nWhat is your first name? "
2019-07-10
这个示例演示了一种创建多行字符串的方式。第1行将消息的前半部分存储在变量prompt 中；在第2行中，运算符+= 在存储在prompt 中的字符串末尾附加一个字符串。
7.1.4　在Python 2.7中获取输入
2019-07-10
如果一个数可被另一个数整除，余数就为0，因此求模运算符将返回0。你可利用这一点来判断一个数是奇数还是偶数：
7.2.2　让用户选择何时退出
2019-07-10
for 循环用于针对集合中的每个元素都一个代码块，而while 循环不断地运行，直到指定的条件不满足为止。
7.2.4　使用break退出循环
2019-07-10
在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于活动状态。这个变量被称为标志 ，充当了程序的交通信号灯。你可让程序在标志为True 时继续运行，并在任何事件导致标志的值为False 时让程序停止运行。这样，在while 语句中就只需检查一个条件——标志的当前值是否为True ，并将所有测试（是否发生了应将标志设置为False 的事件）都放在其他地方，从而让程序变得更为整洁。
2019-07-10
我们将变量active 设置成了True （见❶），让程序最初处于活动状态。这样做简化了while 语句，因为不需要在其中做任何比较——相关的逻辑由程序的其他部分处理。只要变量active 为True ，循环就将继续运行（见❷）。
7.2.5　在循环中使用continue
2019-07-10
在复杂的程序中，如很多事件都会导致程序停止运行的游戏中，标志很有用：在其中的任何一个事件导致活动标志变成False 时，主游戏循环将退出，此时可显示一条游戏结束消息，并让用户选择是否要重新玩。
2019-07-10
注意 　在任何Python循环中都可使用break 语句。例如，可使用break 语句来退出遍历列表或字典的for 循环。
7.2.6　避免无限循环
2019-07-10
continue 语句，让Python忽略余下的代码，并返回到循环的开头
7.3　使用while循环来处理列表和字典
2019-07-10
如果程序陷入无限循环，可按Ctrl + C，也可关闭显示程序输出的终端窗口。
7.3.1　在列表之间移动元素
2019-07-10
要记录大量的用户和信息，需要在while 循环中使用列表和字典。
for 循环是一种遍历列表的有效方式，但在for 循环中不应修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时对其进行修改，可使用while 循环。通过将while 循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。
7.3.2　删除包含特定值的所有列表元素
2019-07-10
while unconfirmed_users:
❸ current_user = unconfirmed_users.pop()
print("Verifying user: " + current_user.title())❹ confirmed_users.append(current_user)
2019-07-10
❷处的while 循环将不断地运行，直到列表unconfirmed_users 变成空的。
7.3.3　使用用户输入来填充字典
2019-07-10
pets = ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat']
print(pets)
while 'cat' in pets: pets.remove('cat')
print(pets)
2019-07-10
进入这个循环后，Python删除第一个'cat' 并返回到while 代码行，然后发现'cat' 还包含在列表中，因此再次进入循环。它不断删除'cat' ，直到这个值不再包含在列表中，然后退出循环并再次打印列表：
7.4　小结
2019-07-10
responses[name] = response
12.3.2　设置背景色
2019-09-15
使用模块sys 来退出游戏。
2019-09-15
实参(1200, 800) 是一个元组，指定了游戏窗口的尺寸。通过将这些尺寸值传递给pygame.display.set_mode() ，我们创建了一个宽1200像素、高800像素的游戏窗口（你可以根据自己的显示器尺寸调整这些值）。
2019-09-15
在这个游戏中，每个元素（如外星人或飞船）都是一个surface。
2019-09-15
为访问Pygame检测到的事件，我们使用方法pygame.event.get() 。所有键盘和鼠标事件都将促使for 循环运行。在这个循环中，我们将编写一系列的if 语句来检测并响应特定的事件。
2019-09-15
pygame.display.flip() ，命令Pygame让最近绘制的屏幕可见。在这里，它在每次执行while 循环时都绘制一个空屏幕，并擦去旧屏幕，使得只有新屏幕可见。在我们移动游戏元素时，pygame.display.flip() 将不断更新屏幕，以显示元素的新位置，并在原来的位置隐藏元素，从而营造平滑移动的效果。
12.4　添加飞船图像
2019-09-15
我们调用方法screen.fill() ，用背景色填充屏幕；这个方法只接受一个实参：一种颜色。
12.4.1　创建Ship类
2019-09-15
为游戏选择素材时，务必要注意许可。最安全、最不费钱的方式是使用http://pixabay.com/ 等网站提供的图形，这些图形无需许可，你可以对其进行修改。
在游戏中几乎可以使用任何类型的图像文件，但使用位图（.bmp）文件最为简单，因为Pygame默认加载位图。虽然可配置Pygame以使用其他文件类型，但有些文件类型要求你在计算机上安装相应的图像库。
12.4.2　在屏幕上绘制飞船
2019-09-15
# 加载飞船图像并获取其外接矩形
❶ self.image = pygame.image.load('images/ship.bmp')❷ self.rect = self.image.get_rect()
❸ self.screen_rect = screen.get_rect()
# 将每艘新飞船放在屏幕底部中央❹ self.rect.centerx = self.screen_rect.centerx
self.rect.bottom = self.screen_rect.bottom
❺ def blitme(self): """在指定位置绘制飞船"""
self.screen.blit(self.image, self.rect)
2019-09-15
为加载图像，我们调用了pygame.image.load() （见❶）。这个函数返回一个表示飞船的surface，而我们将这个surface存储到了self.image 中。
2019-09-15
处理rect 对象时，可使用矩形四角和中心的 x 和 y 坐标。可通过设置这些值来指定矩形的位置。
要将游戏元素居中，可设置相应rect 对象的属性center 、centerx 或centery 。要让游戏元素与屏幕边缘对齐，可使用属性top 、bottom 、left 或right ；要调整游戏元素的水平或垂直位置，可使用属性x 和y ，它们分别是相应矩形左上角的 x 和 y 坐标。这些属性让你无需去做游戏开发人员原本需要手工完成的计算，你经常会用到这些属性。注意 　在Pygame中，原点(0, 0)位于屏幕左上角，向右下方移动时，坐标值将增大。在1200×800的屏幕上，原点位于左上角，而右下角的坐标为(1200, 800)。
12.5.1　函数check_events()
2019-09-15
填充背景后，我们调用ship.blitme() 将飞船绘制到屏幕上，确保它出现在背景前面（见❷）。
12.5.2　函数update_screen()
2019-09-15
通过创建模块game_functions ，可避免alien_invasion.py太长，并使其逻辑更容易理解。
2019-09-15
我们将首先把管理事件的代码移到一个名为check_events() 的函数中，以简化run_game() 并隔离事件管理循环。通过隔离事件循环，可将事件管理与游戏的其他方面（如更新屏幕）分离。
将check_events() 放在一个名为game_functions 的模块中：game_functions.py
12.6.1　响应按键
2019-09-15
鉴于我们一开始只想使用一个文件，因此没有立刻引入模块game_functions 。这让你能够了解实际的开发过程：一开始将代码编写得尽可能简单，并在项目越来越复杂时进行重构。
12.6.2　允许不断移动
2019-09-15
检测到KEYDOWN 事件时，我们需要检查按下的是否是特定的键。例如，如果按下的是右箭头键，我们就增大飞船的rect.centerx 值，将飞船向右移动：
2019-09-15
elif event.type == pygame.KEYDOWN:
❷ if event.key == pygame.K_RIGHT: #向右移动飞船
❸ ship.rect.centerx += 1
2019-09-15
在alien_invasion.py中，我们需要更新调用的check_events() 代码，将ship 作为实参传递给它：
alien_invasion.py
# 开始游戏主循环 while True:
gf.check_events(ship) gf.update_screen(ai_settings, screen, ship)
12.6.3　左右移动
2019-09-15
如果现在运行alien_invasion.py，则每按右箭头键一次，飞船都将向右移动1像素。这是一个开端，但并非控制飞船的高效方式。下面来改进控制方式，允许持续移动。
2019-09-15
玩家按住右箭头键不放时，我们希望飞船不断地向右移动，直到玩家松开为止。我们将让游戏检测pygame.KEYUP 事件，以便玩家松开右箭头键时我们能够知道这一点；然后，我们将结合使用KEYDOWN 和KEYUP 事件，以及一个名为moving_right 的标志来实现持续移动。
2019-09-15
飞船不动时，标志moving_right 将为False 。玩家按下右箭头键时，我们将这个标志设置为True ；而玩家松开时，我们将这个标志重新设置为False 。
飞船的属性都由Ship 类控制，因此我们将给这个类添加一个名为moving_right 的属性和一个名为update() 的方法。方法update() 检查标志moving_right 的状态，如果这个标志为True ，就调整飞船的位置。每当需要调整飞船的位置时，我们都调用这个方法。下面是对Ship 类所做的修改：
ship.py
class Ship():
def __init__(self, screen): --snip--
# 将每艘新飞船放在屏幕底部中央 self.rect.centerx = self.screen_rect.centerx
self.rect.bottom = self.screen_rect.bottom
# 移动标志❶ self.moving_right = False
❷ def update(self):
"""根据移动标志调整飞船的位置""" if self.moving_right:
self.rect.centerx += 1
2019-09-15
elif event.type == pygame.KEYDOWN:
if event.key == pygame.K_RIGHT:❶ ship.moving_right = True
❷ elif event.type == pygame.KEYUP:
if event.key == pygame.K_RIGHT: ship.moving_right = False
2019-09-15
最后，我们需要修改alien_invasion.py 中的while 循环，以便每次执行循环时都调用飞船的方法update() ：
alien_invasion.py
# 开始游戏主循环 while True:
gf.check_events(ship) ship.update()
gf.update_screen(ai_settings, screen, ship)



飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新。这样，玩家输入时，飞船的位置将更新，从而确保使用更新后的位置将飞船绘制到屏幕上。
12.6.4　调整飞船的速度
2019-09-15
if self.moving_right:
self.rect.centerx += 1 if self.moving_left:
self.rect.centerx -= 1
2019-09-15
在方法update() 中，我们添加了一个if 代码块而不是elif 代码块，这样如果玩家同时按下了左右箭头键，将先增大飞船的rect.centerx 值，再降低这个值，即飞船的位置保持不变。如果使用一个elif 代码块来处理向左移动的情况，右箭头键将始终处于优先地位。从向左移动切换到向右移动时，玩家可能同时按住左右箭头键，在这种情况下，前面的做法让移动更准确。
2019-09-15
如果因玩家按下K_LEFT 键而触发了KEYDOWN 事件，我们就将moving_left 设置为True ；如果因玩家松开K_LEFT 而触发了KEYUP 事件，我们就将moving_left 设置为False 。这里之所以可以使用elif 代码块，是因为每个事件都只与一个键相关联；如果玩家同时按下了左右箭头键，将检测到两个不同的事件。
12.6.5　限制飞船的活动范围
2019-09-15
下面来进一步优化飞船的移动方式：调整飞船的速度；限制飞船的移动距离，以免它移到屏幕外面去。
2019-09-15
当前，每次执行while 循环时，飞船最多移动1像素，但我们可以在Settings 类中添加属性ship_speed_factor ，用于控制飞船的速度。我们将根据这个属性决定飞船在每次循环时最多移动多少距离。
2019-09-15
通过将速度设置指定为小数值，可在后面加快游戏的节奏时更细致地控制飞船的速度。然而，rect 的centerx 等属性只能存储整数值，因此我们需要对Ship 类做些修改：
2019-09-15
# 在飞船的属性center中存储小数值
❸ self.center = float(self.rect.centerx)
2019-09-15
# 更新飞船的center值，而不是rect
if self.moving_right:❹ self.center += self.ai_settings.ship_speed_factor
if self.moving_left: self.center -= self.ai_settings.ship_speed_factor
# 根据self.center更新rect对象
❺ self.rect.centerx = self.center
2019-09-15
鉴于现在调整飞船的位置时，将增加或减去一个单位为像素的小数值，因此需要将位置存储在一个能够存储小数值的变量中。可以使用小数来设置rect 的属性，但rect 将只存储这个值的整数部分。为准确地存储飞船的位置，我们定义了一个可存储小数值的新属性self.center （见❸）。我们使用函数float() 将self.rect.centerx 的值转换为小数，并将结果存储到self.center 中。
现在在update() 中调整飞船的位置时，将self.center 的值增加或减去ai_settings.ship_speed_factor 的值（见❹）。更新self.center 后，我们再根据它来更新控制飞船位置的self.rect.centerx （见❺）。self.rect.centerx 将只存储self.center 的整数部分，但对显示飞船而言，这问题不大。
12.7.4　ship.py
2019-09-15
主文件alien_invasion.py创建一系列整个游戏都要用到的对象：存储在ai_settings 中的设置、存储在screen 中的主显示surface以及一个飞船实例。文件alien_invasion.py还包含游戏的主循环，这是一个调用check_events() 、ship.update() 和update_screen() 的while 循环。
12.8.2　创建Bullet类
2019-09-15
首先，更新settings.py，在其方法__init__() 末尾存储新类Bullet 所需的值：
12.8.3　将子弹存储到编组中
2019-09-15
这些设置创建宽3像素、高15像素的深灰色子弹。子弹的速度比飞船稍低。
2019-09-15
import pygame
from pygame.sprite import Sprite
class Bullet(Sprite):
2019-09-15
"""一个对飞船发射的子弹进行管理的类"""
def __init__(self, ai_settings, screen, ship):
"""在飞船所处的位置创建一个子弹对象""" super(Bullet, self).__init__()
self.screen = screen
# 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置❶ self.rect = pygame.Rect(0, 0, ai_settings.bullet_width,
ai_settings.bullet_height)❷ self.rect.centerx = ship.rect.centerx
❸ self.rect.top = ship.rect.top
#存储用小数表示的子弹位置❹ self.y = float(self.rect.y)
❺ self.color = ai_settings.bullet_color
self.speed_factor = ai_settings.bullet_speed_factor
2019-09-15
Bullet 类继承了我们从模块pygame.sprite 中导入的Sprite 类。通过使用精灵，可将游戏中相关的元素编组，进而同时操作编组中的所有元素。为创建子弹实例，需要向__init__() 传递ai_settings 、screen 和ship 实例，还调用了super() 来继承Sprite 。
注意 　代码super(Bullet, self).__init__() 使用了Python 2.7语法。这种语法也适用于Python 3，但你也可以将这行代码简写为super().__init__() 。
2019-09-15
子弹并非基于图像的，因此我们必须使用pygame.Rect() 类从空白开始创建一个矩形。创建这个类的实例时，必须提供矩形左上角的 x 坐标和 y 坐标，还有矩形的宽度和高度。
2019-09-15
def draw_bullet(self):
"""在屏幕上绘制子弹"""❸ pygame.draw.rect(self.screen, self.color, self.rect)
12.8.4　开火
2019-09-16
我们将在alien_invasion.py中创建一个编组（group），用于存储所有有效的子弹，以便能够管理发射出去的所有子弹。这个编组将是pygame.sprite.Group 类的一个实例；pygame.sprite.Group 类类似于列表，但提供了有助于开发游戏的额外功能。在主循环中，我们将使用这个编组在屏幕上绘制子弹，以及更新每颗子弹的位置：
2019-09-16
from pygame.sprite import Group
2019-09-16
# 创建一个用于存储子弹的编组
❶ bullets = Group()
# 开始游戏主循环 while True:
gf.check_events(ai_settings, screen, ship, bullets) ship.update()
❷ bullets.update() gf.update_screen(ai_settings, screen, ship, bullets)
2019-09-16
我们导入了pygame.sprite 中的Group 类。在❶处，我们创建了一个Group 实例，并将其命名为bullets 。这个编组是在while 循环外面创建的，这样就无需每次运行该循环时都创建一个新的子弹编组。
12.8.5　删除已消失的子弹
2019-09-16
当你对编组调用update() 时，编组将自动对其中的每个精灵调用update() ，因此代码行bullets.update()
2019-09-16
将为编组bullets 中的每颗子弹调用bullet.update() 。
2019-09-16
from bullet import Bullet
❶ def check_keydown_events(event, ai_settings, screen, ship, bullets):
--snip--❷ elif event.key == pygame.K_SPACE:
# 创建一颗子弹，并将其加入到编组bullets中 new_bullet = Bullet(ai_settings, screen, ship)
bullets.add(new_bullet)
2019-09-16
❹ def update_screen(ai_settings, screen, ship, bullets):
--snip-- # 在飞船和外星人后面重绘所有子弹
❺ for bullet in bullets.sprites(): bullet.draw_bullet()
ship.blitme() --snip--
2019-09-16
编组bulltes 传递给了check_keydown_events() （见❶）。玩家按空格键时，创建一颗新子弹（一个名为new_bullet 的Bullet 实例），并使用方法add() 将其加入到编组bullets 中（见❷）；代码bullets.add(new_bullet) 将新子弹存储到编组bullets 中。
2019-09-16
在❹处，我们给在屏幕上绘制子弹的update_screen() 添加了形参bullets 。方法bullets.sprites() 返回一个列表，其中包含编组bullets 中的所有精灵。为在屏幕上绘制发射的所有子弹，我们遍历编组bullets 中的精灵，并对每个精灵都调用draw_bullet() （见❺）。
12.8.6　限制子弹数量
2019-09-16
我们需要将这些已消失的子弹删除，否则游戏所做的无谓工作将越来越多，进而变得越来越慢。为此，我们需要检测这样的条件，即表示子弹的rect 的bottom 属性为零，它表明子弹已穿过屏幕顶端：
2019-09-16
# 删除已消失的子弹
❶ for bullet in bullets.copy():❷ if bullet.rect.bottom <= 0:
❸ bullets.remove(bullet)❹ print(len(bullets))
12.8.7　创建函数update_bullets()
2019-09-16
在for 循环中，不应从列表或编组中删除条目，因此必须遍历编组的副本。我们使用了方法copy() 来设置for 循环（见❶），这让我们能够在循环中修改bullets 。我们检查每颗子弹，看看它是否已从屏幕顶端消失（见❷）。如果是这样，就将其从bullets 中删除（见❸）。在❹处，我们使用了一条print 语句，以显示当前还有多少颗子弹，从而核实已消失的子弹确实删除了。
2019-09-16
运行这个游戏并确认子弹已被删除后，将这条print 语句删除。如果你留下这条语句，游戏的速度将大大降低，因为将输出写入到终端而花费的时间比将图形绘制到游戏窗口花费的时间还多。
2019-09-16
很多射击游戏都对可同时出现在屏幕上的子弹数量进行限制，以鼓励玩家有目标地射击。
12.8.8　创建函数fire_bullet()
2019-09-16
编写并检查子弹管理代码后，可将其移到模块game_functions 中，以让主程序文件alien_invasion.py尽可能简单。
2019-09-16
while True:
❶ gf.check_events(ai_settings, screen, ship, bullets)❷ ship.update()
❸ gf.update_bullets(bullets)❹ gf.update_screen(ai_settings, screen, ship, bullets)
第 13 章　外星人
2019-09-16
我们让主循环包含尽可能少的代码，这样只要看函数名就能迅速知道游戏中发生的情况。主循环检查玩家的输入（见❶），然后更新飞船的位置（见❷）和所有未消失的子弹的位置（见❸）。接下来，我们使用更新后的位置来绘制新屏幕（见❹）。
13.1　回顾项目
2019-09-16
在本章中，我们将在游戏《外星人入侵》中添加外星人。首先，我们在屏幕上边缘附近添加一个外星人，然后生成一群外星人。我们让这群外星人向两边和下面移动，并删除被子弹击中的外星人。最后，我们将显示玩家拥有的飞船数量，并在玩家的飞船用完后结束游戏。
2019-09-16
检测碰撞有助于你定义游戏元素之间的交互：可以将角色限定在迷宫墙壁之内或在两个角色之间传球
13.2.1　创建Alien类
2019-09-16
开发较大的项目时，进入每个开发阶段前回顾一下开发计划，搞清楚接下来要通过编写代码来完成哪些任务都是不错的主意。本章涉及以下内容。
研究既有代码，确定实现新功能前是否要进行重构。在屏幕左上角添加一个外星人，并指定合适的边距。
根据第一个外星人的边距和屏幕尺寸计算屏幕上可容纳多少个外星人。我们将编写一个循环来创建一系列外星人，这些外星人填满了屏幕的上半部分。
2019-09-16
让外星人群向两边和下方移动，直到外星人被全部击落，有外星人撞到飞船，或有外星人抵达屏幕底端。如果整群外星人都被击落，我们将再创建一群外星人。如果有外星人撞到了飞船或抵达屏幕底端，我们将销毁飞船并再创建一群外星人。
限制玩家可用的飞船数量，配给的飞船用完后，游戏结束。
2019-09-16
每次为测试新功能而运行这个游戏时，都必须使用鼠标来关闭它，这太讨厌了。下面来添加一个结束游戏的快捷键Q：
13.2.2　创建Alien实例
2019-09-16
from pygame.sprite import Sprite
class Alien(Sprite):
2019-09-16
"初始化外星人并设置其起始位置"""
super(Alien, self).__init__() self.screen = screen
self.ai_settings = ai_settings
2019-09-16
# 每个外星人最初都在屏幕左上角附近
❶ self.rect.x = self.rect.width self.rect.y = self.rect.height
2019-09-16
def blitme(self):
"""在指定位置绘制外星人""" self.screen.blit(self.image, self.rect)
2019-09-16
每个外星人最初都位于屏幕左上角附近，我们将每个外星人的左边距都设置为外星人的宽度，并将上边距设置为外星人的高度（见❶）。
13.3.1　确定一行可容纳多少个外星人
2019-09-16
# 在飞船和外星人后面重绘所有的子弹
for bullet in bullets: bullet.draw_bullet()
ship.blitme() alien.blitme()
2019-09-16
我们先绘制飞船和子弹，再绘制外星人，让外星人在屏幕上位于最前面。
2019-09-17
要绘制一群外星人，需要确定一行能容纳多少个外星人以及要绘制多少行外星人。我们将首先计算外星人之间的水平间距，并创建一行外星人，再确定可用的垂直空间，并创建整群外星人。
13.3.2　创建多行外星人
2019-09-17
由于有两个边距，因此可用于放置外星人的水平空间为屏幕宽度减去外星人宽度的两倍：
available_space_x = ai_settings.screen_width – (2 * alien_width)
2019-09-17
我们还需要在外星人之间留出一定的空间，即外星人宽度。因此，显示一个外星人所需的水平空间为外星人宽度的两倍：一个宽度用于放置外星人，另一个宽度为外星人右边的空白区域。为确定一行可容纳多少个外星人，我们将可用空间除以外星人宽度的两倍：
number_aliens_x = available_space_x / (2 * alien_width)
13.3.3　创建外星人群
2019-09-17
为创建一行外星人，首先在alien_invasion.py中创建一个名为aliens 的空编组，用于存储全部外星人，再调用game_functions.py中创建外星人群的函数：
2019-09-17
aliens = Group()
# 创建外星人群
❷ gf.create_fleet(ai_settings, screen, aliens)
2019-09-17
由于我们不再在alien_invasion.py中直接创建外星人，因此无需在这个文件中导入Alien 类。
❶处创建了一个空编组，用于存储所有的外星人。接下来，调用稍后将编写的函数create_fleet() （见❷），并将ai_settings 、对象screen 和空编组aliens 传递给它。然后，修改对update_screen() 的调用，让它能够访问外星人编组（见❸）。
2019-09-17
我们还需要修改update_screen() ：
game_functions.py
def update_screen(ai_settings, screen, ship, aliens, bullets): --snip--
ship.blitme() aliens.draw(screen)
13.3.4　重构create_fleet()
2019-09-17
对编组调用draw() 时，Pygame自动绘制编组的每个元素，绘制位置由元素的属性rect 决定。在这里，aliens.draw(screen) 在屏幕上绘制编组中的每个外星人。
2019-09-17
from alien import Alien
--snip--
def create_fleet(ai_settings, screen, aliens): """创建外星人群"""
# 创建一个外星人，并计算一行可容纳多少个外星人 # 外星人间距为外星人宽度
❶ alien = Alien(ai_settings, screen)❷ alien_width = alien.rect.width
2019-09-17
# 创建第一行外星人
❺ for alien_number in range(number_aliens_x): # 创建一个外星人并将其加入当前行
❻ alien = Alien(ai_settings, screen) alien.x = alien_width + 2 * alien_width * alien_number
alien.rect.x = alien.x aliens.add(alien)
2019-09-17
为放置外星人，我们需要知道外星人的宽度和高度，因此在执行计算前，我们先创建一个外星人（见❶）。这个外星人不是外星人群的成员，因此没有将它加入到编组aliens 中。在❷处，我们从外星人的rect 属性中获取外星人宽度，并将这个值存储到alien_width 中，以免反复访问属性rect 。
2019-09-17
我们编写了一个循环，它从零数到要创建的外星人数（见❺）。在这个循环的主体中，我们创建一个新的外星人，并通过设置x 坐标将其加入当前行（见❻）。
2019-09-17
。最后，我们将每个新创建的外星人都添加到编组aliens 中。
2019-09-17
我们将让外星人群往右移，触及屏幕边缘后稍微往下移，然后往左移，以此类推。就像经典游戏《太空入侵者》，相比于只往下移，这种移动方式更有趣。
多看笔记 来自多看阅读 for Android
duokanbookid:idc4e99239fec44009916b54bfgg867f
