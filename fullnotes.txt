from selenium import webdriver # create a new Firefox session  driver = webdriver.Firefox()  driver.implicitly_wait(30)  driver.maximize_window() # navigate to the application home page  driver.get("http://demo.magentocommerce.com/") # get the search textbox search_field = driver.find_element_by_name("q")  search_field.clear() # enter search keyword and submit  search_field.send_keys("phones")  search_field.submit() # get all the anchor elements which have product names displayed # currently on result page using find_elements_by_xpath method  products = driver.find_elements_by_xpath("//h2[@class='product-name']/a") # get the number of anchor elements found
print "Found " + str(len(products)) + " products:" # iterate through each anchor element and print the text that is # name of the product for product in products:  　　print product.text  # close the browser window  driver.quit()
import os from selenium import webdriver # get the path of chromedriver dir = os.path.dirname(__file__) chrome_driver_path = dir + "\chromedriver.exe" # remove the .exe extension on linux or mac platform # create a new Chrome session driver = webdriver.Chrome(chrome_driver_path) driver.implicitly_wait(30) driver.maximize_window() # navigate to the application home page driver.get("http://demo.magentocommerce.com/") # get the search textbox search_field = driver.find_element_by_name("q") search_field.clear() # enter search keyword and submit search_field.send_keys("phones") search_field.submit() # get all the anchor 
elements which have product names displayed # currently on result page using find_elements_by_xpath method products = driver.find_elements_by_xpath("//h2[@class='product-name']/a") # get the number of anchor elements found print "Found " + str(len(products)) + " products: " # iterate through each anchor element and print the text that is  # name of the product for product in products: 　　print product.text # close the browser window driver.quit()
unittest使我们具备创建测试用例、测试套件、测试夹具的能力。可以通过下面的图来了解所有的组件。Test Fixture（测试夹具）：通过使用测试夹具，可以定义在单个或多个测试执行之前的准备工作和测试执行之后的清理工作。Test Case（测试用例）：一个测试用例是在unittest中执行测试的最小单元。它通过unittest提供的assert方法来验证一组特定的操作和输入以后得到的具体响应。unittest提供了一个名称为TestCase的基础类，可以用来创建测试用例。
让我们开始使用unittest，首先通过继承TestCase类然后添加一个测试方法，来为第1章（基于Python的Selenium WebDriver入门）中的例子脚本写一个简单的测试。我们需要先引入unittest模块，然后定义一个继承于TestCase 类的子类，具体如下。import unittest from selenium import webdriver class SearchTest (unittest.TestCase)：
一个测试用例是从setUp()方法开始执行的，我们可以用这个方法在每个测试开始前去执行一些初始化的任务。可以是这样的初始化准备：比如创建浏览器实例，访问URL，加载测试数据和打开日志文件等。此方法没有参数，而且不返回任何值。当定义了一个setUp()方法，测试执行器在每次执行测试方法之前优先执行该方法。在下面的例子里，我们将用setUp()方法来创建Firefox的实例，设置properties，而且在测试开始执行之前访问到被测程序的主页。例子如下。
import unittest from selenium import webdriver class SearchTests(unittest.TestCase):     def setUp(self):         # create a new Firefox session         self.driver = webdriver.Firefox()         self.driver.implicitly_wait(30)         self.driver.maximize_window()         # navigate to the application home page         self.driver.get("http://demo.magentocommerce.com/")
添加一个新的测试方法test_search_by_category()，通过分类来搜索产品，然后校验返回的产品的数量是否正确，具体如下。import unittest from selenium import webdriver class SearchTests(unittest.TestCase):     def setUp(self):         # create a new Firefox session         self.driver = webdriver.Firefox()         self.driver.implicitly_wait(30)         self.driver.maximize_window()         # navigate to the application home page         self.driver.get("http://demo.magentocommerce.com/")
 def test_search_by_category(self):         # get the search textbox         self.search_field = self.driver.find_element_by_name("q")         self.search_field.clear()         # enter search keyword and submit         self.search_field.send_keys("phones")         self.search_field.submit()         # get all the anchor elements which have product names         # displayed currently on result page using         # find_elements_by_xpath method         products = self.driver.find_elements_by_xpath           ("//h2[@class='product-name']/a")         self.assertEqual(2, len(products))
import unittest from selenium import webdriver class SearchTests(unittest.TestCase):     def setUp(self):         # create a new Firefox session         self.driver = webdriver.Firefox()         self.driver.implicitly_wait(30)         self.driver.maximize_window()         # navigate to the application home page         self.driver.get("http://demo.magentocommerce.com/")     def test_search_by_category(self):         # get the search textbox         self.search_field = self.driver.find_element_by_name("q")         self.search_field.clear()         # enter search keyword and submit         self.search_field.send_keys("phones")         self.search_field.submit()         # get all the anchor elements which have product names         # displayed 
currently on result page using         # find_elements_by_xpath method         products = self.driver.find_elements_by_xpath           ("//h2[@class='product-name']/a")         self.assertEqual(2, len(products))     def tearDown(self):         # close the browser window         self.driver.quit()
def test_search_by_name(self):         # get the search textbox         self.search_field = self.driver.find_element_by_name("q")         self.search_field.clear()         # enter search keyword and submit         self.search_field.send_keys("salt shaker")         self.search_field.submit()         # get all the anchor elements which have         # product names displayed         # currently on result page using         # find_elements_by_xpath method         products = self.driver.find_elements_by_xpath           ("//h2[@class='product-name']/a")         self.assertEqual(1, len(products))运行这个测试类将能看到两个Firefox的实例打开和关闭，这正是setUp()方法和tearDown()方法针对每个测试方法都要执行产生的结果，如下图所示。
import unittest from selenium import webdriver class SearchTests(unittest.TestCase):     @classmethod     def setUpClass(cls):         # create a new Firefox session         cls.driver = webdriver.Firefox()         cls.driver.implicitly_wait(30)         cls.driver.maximize_window()         # navigate to the application home page         cls.driver.get("http://demo.magentocommerce.com/")         cls.driver.title     def test_search_by_category(self):         # get the search textbox         self.search_field = self.driver.find_element_by_name("q")         self.search_field.clear()         # enter search keyword and submit         self.search_field.send_keys("phones")         self.search_field.submit()         # get all the anchor elements which have product names
# displayed currently on result page using         # find_elements_by_xpath method         products = self.driver.find_elements_by_xpath           ("//h2[@class='product-name']/a")         self.assertEqual(2, len(products))     def test_search_by_name(self):         # get the search textbox         self.search_field = self.driver.find_element_by_name("q")         self.search_field.clear()                # enter search keyword and submit         self.search_field.send_keys("salt shaker")         self.search_field.submit()                # get all the anchor elements which have product names         # displayed currently on result page using         # find_elements_by_xpath method         products = self.driver.find_elements_by_xpath           ("//h2[@class='product-name']/a")
assertRaises(exc, fun, *args, **kwds)fun(*args, **kwds) raises exc这些方法校验特定的异常是否被具体的测试步骤抛出，用到该方法的一种可能情况是： NoSuchElementFoundexceptionassertRaisesRegexp(exc, r, fun, *args, **kwds)fun(*args,**kwds) raises exc and the message matches regex rassertAlmostEqual(a, b)round(a-b, 7) == 0这些方法用于检查数值，在检查之前会按照给定的精度把数字四舍五入。这有助于统计由于四舍五入产生的错误和其他由于浮点运算产生的问题
assertNotAlmostEqual(a, b)round(a-b, 7) != 0assertGreater(a, b)a > b这些方法类似于assertEqual()方法，是为逻辑判定条件设计的assertGreaterEqual(a, b)a >= bassertLess(a, b)a < bassertLessEqual(a, b)a <= bassertRegexpMatches(s, r)r.search(s)这些方法检查文本是否符合正则匹配assertNotRegexpMatches(s, r)not r.search(s)
assertMultiLineEqual(a, b)strings此方法是assertEqual()的一种特殊形式，为多行字符串设计。等值校验和其他单行字符串校验一样，但是默认失败信息经过优化以后可以展示具体值之间的差别assertListEqual(a, b)lists此方法校验两个list是否相等，对于下拉列表选项字段的校验是非常有用的fail()此方法是无条件的失败。在别的assert方法不好用的时候，也可用此方法来创建定制的条件块
import unittest from selenium import webdriver from selenium.common.exceptions import NoSuchElementException from selenium.webdriver.common.by import By from __builtin__ import classmethod class HomePageTest(unittest.TestCase):     @classmethod     def setUp(cls):         # create a new Firefox session """         cls.driver = webdriver.Firefox()         cls.driver.implicitly_wait(30)         cls.driver.maximize_window()         # navigate to the application home page """         cls.driver.get("http://demo.magentocommerce.com/")     def test_search_field(self):
 # check search field exists on Home page         self.assertTrue(self.is_element_present(By.NAME,"q"))     def test_language_option(self):         # check language options dropdown on Home page         self.assertTrue(self.is_element_present           (By.ID,"select-language"))     def test_shopping_cart_empty_message(self):         # check content of My Shopping Cart block on Home page         shopping_cart_icon = \              self.driver.find_element_by_css_selector               ("div.header-minicart span.icon")         shopping_cart_icon.click()         shopping_cart_status = \               self.driver.find_element_by_css_selector                ("p.empty").text         self.assertEqual("You have no items in your shopping cart.", shopping_cart_status)         close_button =  self.driver.find_element_by_css_selector
  ("div.minicart-wrapper a.close")         close_button.click()     @classmethod     def tearDown(cls):         # close the browser window         cls.driver.quit()     def is_element_present(self, how, what):         """         Utility method to check presence of an element on page         :params how: By locator type         :params what: locator value         """         try: self.driver.find_element(by=how, value=what)         except NoSuchElementException, e: return False         return True     if __name__ == '__main__':         unittest.main(verbosity=2)
import unittest from searchtests import SearchTests from homepagetests import HomePageTest # get all tests from SearchProductTest and HomePageTest class search_tests = unittest.TestLoader().loadTestsFromTestCase (SearchTests) home_page_tests = unittest.TestLoader().loadTestsFromTestCase (HomePageTest) # create a test suite combining search_test and home_page_test smoke_tests = unittest.TestSuite([home_page_tests, search_tests]) # run the suite unittest.TextTestRunner(verbosity=2).run(smoke_
import unittest import HTMLTestRunner import os from searchtests import SearchTests from homepagetests import HomePageTest # get the directory path to output report file dir = os.getcwd() # get all tests from SearchProductTest and HomePageTest class search_tests = unittest.TestLoader().loadTestsFromTestCase(SearchTests) home_page_tests = unittest.TestLoader().loadTestsFromTestCase(HomePageTest) # create a test suite combining search_test and home_page_test smoke_tests = unittest.TestSuite([home_page_tests, search_tests])
# open the report file outfile = open(dir + "\SmokeTestReport.html", "w") # configure HTMLTestRunner options runner = HTMLTestRunner.HTMLTestRunner(                  stream=outfile,                  title='Test Report',                  description='Smoke Tests'                  ) # run the suite using HTMLTestRunner runner.run(smoke_tests)
Selenium提供8种find_element_by 方法用于定位元素。接下来的部分，我们将逐一介绍方法细节，如下表所示。方　　法描　　述参　　数示　　例find_element_by_id(id)通过元素的ID属性值来定位元素id：元素的IDdriver.find_element_by_id('search')find_element_by_name(name)通过元素的name属性值来定位元素name：元素的namedriver.find_element_by_name('q')find_element_by_class_name(name)通过元素的class名来定位元素name：元素的类名driver.find_element_by_class_name('input-text')
find_element_by_tag_name(name)通过元素的tag name来定位元素name：tag namedriver.find_element_by_tag_name('input')find_element_by_xpath(xpath)通过XPath来定位元素XPath：元素的XPathdriver.find_element_by_xpath('//form[0]/div[0]/input[0]')find_element_by_css_selector(css_selector)通过CSS选择器来定位元素css_selector：元素的CSS选择器driver.find_element_by_css_selector('#search')find_element_by_link_text(link_text)通过元素标签对之间的文本信息来定位元素link_text：文本信息driver.find_element_by_link_text('Log In')
find_elements_by_xpath(xpath)通过XPath来定位一组元素XPath：元素的XPathdriver.find_elements_by_xpath("//div[contains(@class,'lists')]")find_elements_by_css_selector(css_selector)通过CSS选择器来定位一组元素css_selector：元素的CSS选择器driver.find_elements_by_css_selector('.input-class')
find_elements_by_link_text(text)通过元素标签对之间的文本信息来定位一组元素text：文本信息driver.find_elements_by_link_text('Log In')find_elements_by_partial_link_text(link_text)通过元素标签对之间的部分文本信息来定位一组元素link_text：部分文本信息driver.find_elements_by_partial_link_text('Add to,')
我们使用find_element_by_id() 方法，id值为search来定位搜索框，同时检查maxlength的属性值。def test_search_text_field_max_length(self): 　# get the search textbox 　search_field = self.driver.find_element_by_id("search") 　# check maxlength attribute is set to 128  　self.assertEqual("128", search_field.get_attribute("maxlength"))
搜索按钮（放大镜图标）在HTML中是用<button>标签（元素）以及对应的class属性与属性值定义的，具体如下。<button type="submit" title="Search" 　class="button"><span><span>Search</span></span></button>下面我们用class属性值来定位搜索按钮，代码如下。def test_search_button_enabled(self): 　　# get Search button 　　search_button = self.driver.find_element_by_class_name  　　　("button") 　　# check Search button is enabled  　　self.assertTrue(search_button.is_enabled())
这几张banner图采用无序列表标签<ul>内嵌图像标签<img>来实现。<ul class="promos"> 　　<li> 　　　 <a href="http://demo.magentocommerce.com/home-decor.html">  　　　　　 <img src="/media/wysiwyg/homepage-three-column-promo- 　　　　　　 01B.png" alt="Physical & amp; Virtual Gift Cards"> 　　　 </a>
</li> 　　<li> 　　　 <a href="http://demo.magentocommerce.com/vip.html"> 　　　　　 <img src="/media/wysiwyg/homepage-three-column-promo- 　　　　　　 02.png" alt="Shop Private Sales - Members Only"> 　　　 </a> 　　</li> 　　<li> 　　　 <a href="http://demo.magentocommerce.com/accessories/ bags-luggage.html"> 　　　　　 <img src="/media/wysiwyg/homepage-three-column-
def test_count_of_promo_banners_images(self): 　　# get promo banner list 　　banner_list = self.driver.find_element_by_class_name("promos") 　　# get images from the banner_list 　　banners = banner_list.find_elements_by_tag_name("img") 　　# check there are 20 tags displayed on the page  　　self.assertEqual(2, len(banners))
上图是名为“Shop Private Sales”的banner图，在<img> 的tag下，其中代码并不包含ID、name或class属性等信息，且这个页面还包含很多其他的<img>，所以我们不能通过传统的方法如findby tag_name()简单地定位了。<ul class="promos"> 　　... 　　<li> 　　　 <a href="http://demo.magentocommerce.com/vip.html">  　　　　　<img src="/media/wysiwyg/homepage-three-column- 　　　　　　promo-02.png" alt="Shop Private Sales - Members Only"> 　　　 </a> 　　</li> 　　... </ul>
我们尝试使用find_element_by_xpath()方法，用<img>标签下的 alt 属性值来定位我们要找的元素。代码如下。def test_vip_promo(self): 　　# get vip promo image  　　vip_promo = self.driver.\ 　　　find_element_by_xpath("//img[@alt='Shop Private Sales - Members Only']") 　　# check vip promo logo is displayed on home page  　　self.assertTrue(vip_promo.is_displayed()) 　　# click on vip promo images to open the page 　　vip_promo.click() 　　# check page title 　　self.assertEqual("VIP",　self.driver.title)
回到首页的例子，可以看到购物车按钮，单击这个按钮，将进入购物车页面。如果此时没有添加任何商品，那么系统会提示“你还没有添加商品到购物车”，如下图所示。 HTML代码如下。<div class="minicart-wrapper"> <p class="block-subtitle"> 　　Recently added item(s) 　　<a class="close skip-link-close" href="#" title="Close"> 　　　×</a> </p> 　　<p class="empty">You have no items in your shopping cart. 　　　</p> </div>
　　find_element_by_css_selector("div.header-minicart span.icon") 　　shopping_cart_icon.click()  　　# get the shopping cart status  　　shopping_cart_status = self.driver.\  　　　　find_element_by_css_selector("p.empty").text  　　self.assertEqual("You have no items in your shopping cart.", shopping_cart_status) 　　# close the shopping cart section  　　close_button = self.driver.\  　　　　find_element_by_css_selector("div.minicart-wrapper a.close") 　　close_button.click()
（3）编写测试脚本，先通过文本定位Account链接，然后单击查看是否能显示。def test_my_account_link_is_displayed(self):  　　# get the Account link  　　account_link =  　　　self.driver.find_element_by_link_text("ACCOUNT")  　　# check My Account link is displayed/visible in  　　# the Home page footer  　　self.assertTrue(account_link.is_displayed())
def test_account_links(self):  　　# get the all the links with Account text in it  　　account_links = self.driver.\  　　　　find_elements_by_partial_link_text("ACCOUNT")  　　# check Account and My Account link is displayed/visible in the Home page footer  　　self.assertTrue(2, len(account_links))
import unittest  from selenium import webdriver  class HomePageTest(unittest.TestCase):  　　@classmethod  　　def setUpClass(cls):  　　　　# create a new Firefox session  　　　　cls.driver = webdriver.Firefox()  　　　　cls.driver.implicitly_wait(30)  　　　　cls.driver.maximize_window()  　　　　#navigate to the application home page  　　　　cls.driver.get('http://demo.magentocommerce.com/') 
def test_search_text_field_max_length(self):  　　　　# get the search textbox  　　　　search_field = self.driver.  　　　　　find_element_by_id("search")  　　　　# check maxlength attribute is set to 128  　　　　self.assertEqual("128", search_field.get_attribute  　　　　("maxlength")) 
def test_search_button_enabled(self):  　　　　# get Search button  　　　　search_button = self.driver.  　　　　　find_element_by_class_name("button")  　　　　# check Search button is enabled  　　　　self.assertTrue(search_button.is_enabled()) 
def test_account_links(self):  　　　　# get the all the links with Account text in it  　　　　account_links = self.driver.\  　　　　　find_elements_by_partial_link_text("ACCOUNT")  　　　　# check Account and My Account link is  　　　　# displayed/visible in the Home page footer  　　　　self.assertTrue(2, len(account_links)) 
def test_count_of_promo_banners_images(self):  　　　　# get promo banner list 　　　　banner_list = self.driver.  　　　　　find_element_by_class_name("promos")  　　　　# get images from the banner_list 　　　　banners = banner_list.  　　　　　find_elements_by_tag_name("img")  　　　　# check there are 3 banners displayed on the page  　　　　self.assertEqual(2, len(banners)) 
def test_vip_promo(self):  　　　　# get vip promo image  　　　　vip_promo = self.driver.\  　　　　　　find_element_by_xpath("//img[@alt=  　　　　　　'Shop Private Sales - Members Only']")  　　　　# check vip promo logo is displayed on home page  　　　　self.assertTrue(vip_promo.is_displayed())  　　　　# click on vip promo images to open the page  　　　　vip_promo.click()  　　　　# check page title  　　　　self.assertEqual("VIP", self.driver.title) 
def test_shopping_cart_status(self):  　　　　# check content of My Shopping Cart block  　　　　# on Home page 　　　　# get the Shopping cart icon and click to  　　　　# open the Shopping Cart section  　　　　shopping_cart_icon = self.driver.\  　　　　　find_element_by_css_selector("div.header-  　　　　　　minicart span.icon")  　　　　shopping_cart_icon.click()  　　　　# get the shopping cart status  　　　　shopping_cart_status = self.driver.\  　　　　　find_element_by_css_selector("p.empty").text  　　　　self.assertEqual("You have no items in your shopping  　　　　cart.", shopping_cart_status)  　　　　# close the shopping cart section  　　　　close_button = self.driver.\  　　　　　find_element_by_css_selector("div.minicart-  　　　　　wrapper a.close")  　　　　close_button.click()  　　@classmethod 
def tearDownClass(cls):  　　　　# close the browser window  　　　　cls.driver.quit()  if __name__ == '__main__':  　　unittest.main(verbosity=2)
WebElement提供了一些功能、属性和方法来实现与网页元素的交互。本节的表格中将列出后面章节会用到的一些重要的功能和方法。如果想查看完整的功能和方法详情，请访问以下网站。http://selenium.googlecode.com/git/docs/api/py/webdriver_remote/selenium.webdriver.remote.webelement.html#module-selenium.webdriver.remote.webelement
from selenium import webdriver import unittest class RegisterNewUser(unittest.TestCase): 　　def setUp(self): 　　　　self.driver = webdriver.Firefox 　　　　self.driver.implicitly_wait(30) 　　　　self.driver.maximize_window() 　　　　# navigate to the application home page 　　　　self.driver.get("http://demo.magentocommerce.com/")
（2）添加一个测试方法 test_register_new_user(self) 到RegisterNewUser类中。（3）为了打开登录页面，我们需要单击主页的登录链接。用于登录的代码如下。def test_register_new_user(self):  　　driver = self.driver 　　# click on Log In link to open Login page 　　driver.find_element_by_link_text("Log In").click()
# get the Create Account button 　　　　create_account_button = driver.find_element_by_xpath("// button[@title='Create an Account']") 　　　　# check Create Account button is displayed and enabled 　　　　self.assertTrue(create_account_button.is_displayed() and 　　　　　　　　　　　　create_account_button.is_enabled())
# get all the fields from Create an Account form first_name = driver.find_element_by_id("firstname") last_name = driver.find_element_by_id("lastname") email_address = driver.find_element_by_id("email_address") news_letter_subscription = 　driver.find_element_by_id("is_subscribed") password = driver.find_element_by_id("password") confirm_password = driver.find_element_by_id("confirmation") submit_button = 　driver.find_element_by_xpath("//button[@title='Submit']")
（2）添加以下代码到测试脚本中，以确保所有的字段对于用户都是可见和可用的。# check all fields are enabled 　　　　self.assertTrue(first_name.is_enabled()and last_name.is_enabled() 　　　　　 and email_address.is_enabled() and news_letter_subscription.is_enabled() 　　　　　 and password.is_enabled() and confirm_password.is_enabled() 　　　　　 and submit_button.is_enabled())
# fill out all the fields first_name.send_keys("Test") last_name.send_keys("User1") news_letter_subscription.click() email_address.send_keys("TestUser_150214_2200@example.com") password.send_keys("tester") confirm_password.send_keys("tester")
（2）最终通过校验欢迎信息来检查用户是否创建成功。我们可以通过text 属性来获取元素的文本内容。# check new user is registered self.assertEqual("Hello, Test User1!", driver.find_ 　　element_by_css_selector("p.hello > strong").text) self.assertTrue(driver.find_element_by_link_text("LogOut").is_displayed())
from selenium import webdriver from time import gmtime, strftime  import unittest class RegisterNewUser(unittest.TestCase): 　　def setUp(self): 　　　　self.driver = webdriver.Firefox() 　　　　self.driver.implicitly_wait(30) 　　　　self.driver.maximize_window() 　　　　# navigate to the application home page 　　　　self.driver.get("http://demo.magentocommerce.com/")
def test_register_new_user(self): 　　　　driver = self.driver 　　　　# click on Log In link to open Login page 　　　　driver.find_element_by_link_text("ACCOUNT").click() 　　　　driver.find_element_by_link_text("My Account").click() 　　　　# get the Create Account button 　　　　create_account_button = \ 　　　　　　driver.find_element_by_link_text("CREATE AN ACCOUNT") 　　　　# check Create Account button is displayed 　　　　# and enabled
　self.assertTrue(create_account_button. 　　　　　is_displayed() and 　　　　　create_account_button.is_enabled()) 　　　　# click on Create Account button. This will 　　　　# display new account 　　　　create_account_button.click() 　　　　# check title 　　　　self.assertEquals("Create New Customer Account", driver.title) 　　　　# get all the fields from Create an Account form 　　　　first_name = driver.find_element_by_id("firstname") 　　　　last_name = driver.
find_element_by_id("lastname") 　　　　email_address = driver.find_element_by_id("email_address") 　　　　password = driver.find_element_by_id("password") 　　　　confirm_password = driver.find_element_by_id("confirmation") 　　　　news_letter_subscription = driver.find_element_by_id("is_subscribed") 　　　　submit_button = driver.\find_element_by_xpath ("//button[@title='Register']") 　　　　# check maxlength of first name and
　# last name textbox 　　　　self.assertEqual("255", first_name.get_attribute("maxlength")) 　　　　self.assertEqual("255", last_name.get_attribute("maxlength")) 　　　　# check all fields are enabled 　　　　self.assertTrue(first_name.is_enabled() 　　　　　and last_name.is_enabled() 　　　　　and email_address.is_enabled() and 　　　　　news_letter_subscription.is_enabled() and 　　　　　password.is_enabled() and 　　　　　confirm_password.
is_enabled() 　　　　　and submit_button.is_enabled()) 　　　　# check Sign Up for Newsletter is unchecked 　　　　self.assertFalse(news_letter_subscription. is_selected()) 　　　　user_name = "user_" + strftime ("%Y%m%d%H%M%S", gmtime()) 　　　　# fill out all the fields 　　　　first_name.send_keys("Test") 　　　　last_name.send_keys(user_name) 　　　　news_letter_subscription.click() 　　　　email_address.send_keys(user_name + "@example.
com") 　　　　password.send_keys("tester") 　　　　confirm_password.send_keys("tester") 　　　　# click Submit button to submit the form 　　　　submit_button.click() 　　　　# check new user is registered 　　　　self.assertEqual("Hello, Test " + user_name + "!", 　　　　　 driver.find_element_by_css_selector("p.hello >strong").text) 　　　　driver.find_element_by_link_text("ACCOUNT").click() 　　　　self.assertTrue(driver.find_element_by_link_
text ("Log Out").is_displayed()) 　　def tearDown(self): 　　　　self.driver.quit() if __name__ == "__main__": 　　unittest.main(verbosity=2)
下拉菜单和列表是通过HTML的<select> 元素实现的。选择项是通过<select>中的<option>元素实现的，如下HTML代码。<select id="select-language" title="Your Language" 　onchange="window.location.href=this.value"> 　<option value="http://demo.magentocommerce.com/? 　　___store=default&amp;___from_store=default" 　　selected="selected">English</option> 　<option value="http://demo.magentocommerce.com/? 　　___store=french&amp;___from_store=default">French</option> 　<option value="http://demo.magentocommerce.com/? 　　___store=german&amp;___from_store=default">German</option> </select>
Select 类是Selenium的一个特定的类，用于与下拉菜单和列表交互。它提供了丰富的功能和方法来实现与用户交互。下面两小节的表格列出来Select类中所有的功能和方法。你也可以在下面网址获取类似信息。http://selenium.googlecode.com/git/docs/api/py/webdriver_support/selenium.webdriver.support.select.html#module- selenium.webdriver.support.select
功能/属性描　　述实　　例all_selected_options获取下拉菜单和列表中被选中的所有选项内容select_element.all_selected_optionsfirst_selected_option获取下拉菜单和列表的第一个选项／当前选择项select_element.first_selected_optionoptions获取下拉菜单和列表的所有选项select_element.options4.5.3　Select方法
deselect_by_value(value)清除所有选项值和给定参数匹配的下拉菜单和列表的选择项value：要清除的目标选择项的value属性select_element.deselect_by_value("foo")deselect_ by_visible_text(text)清除所有展示的文本和给定参数匹配的下拉菜单和列表的选择项text：要清除的目标选择项的文本值select_element.deselect_by_visible_text("bar")
def test_language_options(self): 　　# list of expected values in Language dropdown 　　exp_options = ["ENGLISH", "FRENCH", "GERMAN"] 　　# empty list for capturing actual options displayed 　　# in the dropdown 　　act_options = [] 　　# get the Your language dropdown as instance of Select class 　　select_language = \ 　　　　Select(self.driver.find_element_by_id("select-language")) 　　# check number of 
options in dropdown 　　self.assertEqual(2, len(select_language.options)) 　　# get options in a list  　　for option in select_language.options: 　　　　act_options.append(option.text) 　　# check expected options list with actual options list 　　self.assertListEqual(exp_options, act_options) 　　# check default selected option is English 　　self.assertEqual("ENGLISH", select_language.first_selected_option. text) 　　# select an option using select_by_visible text
　select_language.select_by_visible_text("German") 　　# check store is now German 　　self.assertTrue("store=german" in self.driver.current_url) 　　# changing language will refresh the page, 　　# we need to get find language dropdown once again 　　select_language = \ 　　　 Select(self.driver.find_element_by_id("select-language")) 　　　　select_language.select_by_index(0)
# select an option using select_by_visible text select_language.select_by_visible_text("German") # check store is now German self.assertTrue("store=german" in self.driver.current_url)一个或多个选项可以基于索引来选择（该选项在列表中的位置），也可以根据属性值或者文本值来选择。select类提供了很多select_ 方法来选择选项。在上面这个例子中，我们使用select_by_visible_text() 方法来选择选项。反之，我们也可以用各种deselect_ 方法来取消选择。
self.driver.get("http://demo.magentocommerce.com/") 　　def test_compare_products_removal_alert(self): 　　　　# get the search textbox 　　　　search_field = self.driver.find_element_by_name("q") 　　　　search_field.clear() 　　　　# enter search keyword and submit 　　　　search_field.send_keys("phones") 　　　　 search_field.submit() 　　　　# click the Add to compare link
当单击Add to Compare 链接将一个产品添加到比较列表时，将会看到一个产品添加到COMPARE PRODUCTS 下面。这个时候还可以添加其他的产品到比较列表。如果想从比较列表移除所有的产品，可以在COMPARE PRODUCTS 模块单击Clear All 链接。这个时候可以看到一个警告提示“是否确认移除所有的产品”。我们可以通过Alert来操控这个警告。调用WebDirver 的Switch_to_alert() 方法可以返回一个Alert的实例。我们可以利用这个Alert 实例来获取警告信息，并通过单击OK按钮来接受这个警告信息，或者通过单击Cancel 按钮来拒绝这个警告。添加下面的代码到测试脚本中，这部分代码用来读取并且校验警告信息是否正确，然后通过调用accept() 方法来接受警告。
# click on Remove this item link, this will display 　　# an alert to the user 　　self.driver.find_element_by_link_text("Clear All").click() 　　# switch to the alert 　　alert = self.driver.switch_to_alert() 　　# get the text from alert 　　alert_text = alert.text 　　# check alert text 　　self.assertEqual("Are you sure you would like to 　　　remove all products from your comparison?", alert_text) 　　# click on Ok button 　　alert.accept() 　　def tearDown(self): 　　　　self.driver.quit() if __name__ == "__main__": 　　　unittest.main()
import unittest from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions class NavigationTest(unittest.TestCase): 　　def setUp(self): 　　　# create a new Firefox session 　　　self.driver = webdriver.Chrome() 　　　self.driver.implicitly_wait(30) 　　　self.driver.maximize_window() 　　　# navigate to the application home page 　　　self.driver.get("http://www.google.com") 　　def testBrowserNavigation(self): 　　　driver = self.driver 　　　# get the search textbox 　　　search_field = driver.find_element_by_name("q")
search_field.clear() 　　　# enter search keyword and submit 　　　search_field.send_keys("selenium webdriver") 　　　search_field.submit() 　　　se_wd_link = driver.find_element_by_link_text("Selenium WebDriver") 　　　se_wd_link.click() 　　　self.assertEqual("Selenium WebDriver", driver.title) 　　　driver.back() 　　　self.assertTrue(WebDriverWait(self.driver, 10) 　　　　　.until(expected_conditions.title_is 　　　　　　("selenium webdriver - Google Search"))
) 　　　driver.forward() 　　　self.assertTrue(WebDriverWait(self.driver, 10) 　　　　　.until(expected_conditions.title_is 　　　　　　("Selenium WebDriver"))) 　　　driver.refresh() 　　　self.assertTrue(WebDriverWait(self.driver, 10) 　　　　.until(expected_conditions.title_is 　　　　　("Selenium WebDriver"))) 　　def tearDown(self): 　　　# close the browser window 　　　self.driver.quit()
self.driver.implicitly_wait(30) 　　　　self.driver.maximize_window() 　　　　# navigate to the application home page 　　　　self.driver.get("http://demo.magentocommerce.com/") 　　def test_search_by_category(self): 　　　　# get the search textbox 　　　　self.search_field = self.driver.find_element_by_name("q") 　　　　self.search_field.clear() 　　　　# enter search keyword and submit 　　　　self.search_field.
send_keys("phones") 　　　　self.search_field.submit() 　　　　# get all the anchor elements which have product names 　　　　# displayed currently on result page using 　　　　# find_elements_by_xpath method 　　　　products = self.driver\ 　　　　　　.find_elements_by_xpath 　　　　　　　　("//h2[@class='product-name']/a") 　　　　# check count of products shown in results 　　　　self.assertEqual(2, len(products))
def tearDown(self): 　　　　# close the browser window 　　　　self.driver.quit() if __name__ == '__main__': 　　unittest.main(verbosity=2)
from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions import unittest class ExplicitWaitTests(unittest.TestCase): 　　def setUp(self): 　　　　self.driver = webdriver.Firefox() 　　　　self.driver.get("http://demo.magentocommerce.com/") 　　def test_account_link(self): 　　　　WebDriverWait(self.driver, 10)\ 　　　　　　.until(lambda s: s.find_element_by_id("
select- 　　　　　　　language").get_attribute("length") == "3") 　　　　account = WebDriverWait(self.driver, 10)\ 　　　　　　.until(expected_conditions. 　　　　　　　visibility_of_element_located 　　　　　　　　　((By.LINK_TEXT, "ACCOUNT"))) 　　　　account.click() 　　def tearDown(self): 　　　　self.driver.quit() if __name__ == "__main__": 　　unittest.main(verbosity=2)
element_to_be_clickable(locator)等待通过定位器查找的元素可见并且可用，以便确定元素是可点击的。 此方法返回定位到的元素locator: 一组（by,locator）WebDriverWait(self.driver, 10).until(expected_conditions.element_to_be_clickable((By.NAME,"is_subscribed")))
element_to_be_selected(element)等待直到指定的元素被选中element： 是个WebElementsubscription = self.driver.find_element_by_name("is_subscribed") WebDriverWait(self.driver, 10). until(expected_conditions. element_to_be_selected(subscription)
invisibility_of_element_located(locator)等待一个元素在DOM中不可见或不存在locator: 一组（by,locator）WebDriverWait(self.driver, 10). until(expected_conditions. invisibility_of_element_located((By. ID,"loading_banner")))
presence_of_all_elements_located(locator)等待直到至少有一个定位器查找匹配到的目标元素出现在网页中。 该方法返回定位到的一组WebElementlocator: 一组（by,locator）WebDriverWait(self.driver, 10). until(expected_conditions.presence_of_all_elements_located((By.CLASS _NAME,"input-text")))
presence_of_element_located(locator)等待直到定位器查找匹配到的目标元素出现在网页中或可以在DOM中找到。 该方法返回一个被定位到的元素locator: 一组（by,locator）WebDriverWait(self.driver, 10). until(expected_conditions.presence_of_element_located((By.ID,"search")))
text_to_be_present_in_element(locator,text_)等待直到元素能被定位到并且带有相应的文本信息locator: 一组（by,locator） text:需要被校验的文本内容WebDriverWait(self.driver,10). until(expected_conditions.text_to_be_present_in_element((By.ID,"select-language"),"English"))
title_contains(title)等待网页标题包含指定的大小写敏感的字符串。 该方法在匹配成功时返回True，否则返回Falsetitle: 被校验的包含在标题中的字符串WebDriverWait(self.driver, 10). until(expected_conditions.title_contains("Create NewCustomer Account"))
title_is(title)等待网页标题与预期的标题相一致。 该方法在匹配成功时返回True，否则返回Falsetitle:网页的标题WebDriverWait(self.driver, 10). until(expected_conditions.title_is("Create New CustomerAccount -MagentoCommerce Demo Store"))
visibility_of(element)等待直到元素出现在DOM中，是可见的，并且宽和高都大于0。 一旦其变成可见的，该方法将返回（同一个）WebElementelement ： 目标WebElementfirst_name = self.driver.find_element_by_id("firstname") WebDriverWait(self.driver, 10). until(expected_conditions.visibility_of(first_name))
visibility_of_element_located(locator)等待直到根据定位器查找的目标元素出现在DOM中，是可见的，并且宽和高都大于0。 一旦其变成可见的，该方法将返回WebElementlocator: 一组（by,locator）WebDriverWait(self.driver, 10). until(expected_conditions.visibility_of_element_located((By.ID,"firstname")))
def test_create_new_customer(self): 　　# click on Log In link to open Login page 　　self.driver.find_element_by_link_text("ACCOUNT").click() 　　# wait for My Account link in Menu 　　my_account = WebDriverWait(self.driver, 10)\ 　　　　.until(expected_conditions.visibility_of_element_located((By. 　　LINK_TEXT, "My Account")
)) 　　my_account.click() 　　# get the Create Account button 　　create_account_button = WebDriverWait(self.driver, 10)\ 　　　　.until(expected_conditions.element_to_be_clickable((By.LINK_ 　　　　TEXT, "CREATE AN ACCOUNT"))) 　　# click on Create Account button. This will displayed new account 　　create_account_button.click() 　　WebDriverWait(self.driver, 10)\ 　　　　.until(expected_conditions.title_contains("
from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.common.by import By from selenium.webdriver.support import expected_conditions import unittest class CompareProducts(unittest.TestCase): 　　def setUp(self): 　　　　self.driver = 
webdriver.Firefox() 　　　　self.driver.get("http://demo.magentocommerce.com/") 　　def test_compare_products_removal_alert(self): 　　　　# get the search textbox 　　　　search_field = self.driver.find_element_by_name("q") 　　　　search_field.clear() 　　　　# enter search keyword and submit 　　　　search_field.send_keys("phones") 　　　　search_field.submit() 　　　　# click the Add to compare link 　　　　self.driver.\
　find_element_by_link_text("Add to Compare").click() 　　　　# wait for Clear All link to be visible 　　　　clear_all_link = WebDriverWait(self.driver, 10)\ 　　　　　　.until(expected_conditions.visibility_of_element_ 　　　　　　located((By.LINK_TEXT, "Clear All"))) 　　　　# click on Clear All link, 　　　　# this will display an alert to the user 　　　　clear_all_link.click() 　　　　# wait for the alert to present
　alert = WebDriverWait(self.driver, 10)\ 　　　　　　.until(expected_conditions.alert_is_present()) 　　　　# get the text from alert 　　　　alert_text = alert.text 　　　　# check alert text 　　　　self.assertEqual("Are you sure you would like 　to remove all products from your comparison?", alert_text) 　　　　# click on Ok button 　　　　alert.accept() 　　def tearDown(self): 　　　　self.driver.quit() if __name__ == "__main__": 　　unittest.main(verbosity=2)
def testLoginLink(self): 　　WebDriverWait(self.driver, 10).until 　　　(lambda s: s.find_element_by_id 　　　("select-language").get_attribute("length") == "3") 　 　　login_link = WebDriverWait 　　　(self.driver, 10).until(expected_conditions. 　　　 visibility_of_element_located((By.LINK_TEXT,"Log In"))) 　　　 login_link.click();
本章将学习如何在远程机器上执行测试，并且学习如何在由不同浏览器和操作系统组合成的分布式架构中的远程机器上批量执行跨浏览器测试。这种执行跨浏览器测试的实现方式将会节省大量的时间。本章包含以下主题：Selenium Standalone Server 的下载和使用；如何使用Remote 类来实现在Selenium Standalone Server 上执行测试；在Selenium Standalone Server上执行测试；为Selenium Standalone Server添加节点，从而为分布式执行创建一个Grid；在安装有多浏览器和操作系统组合的Grid上执行测试；通过Sauce Labs 和BrowserStack在云端执行测试。
Appium对于Android应用程序的测试是通过调用内置在Android SDK中的 UI Automator来实现的。过程非常类似于基于iOS平台的测试。Appium 作为一个HTTP Server来接收测试脚本通过JSON Wire Protocol传输过来的指令。Appium发送这些指令给UI Automator。这样，这些指令就可以在启动了被测应用的模拟器或者真机上执行测试。这个过程中，Appium把JSON指令翻译成UI Automator 能够理解的Java命令。这个过程如下图所示。
import unittest from appium import webdriver class SearchProductsOnAndroid(unittest.TestCase): 　　def setUp(self): 　　　　desired_caps = {} 　　　　# platform 　　　　desired_caps['device'] = 'Android' 　　　　# platform version 　　　　desired_caps['version'] = '4.3' 　　　　# mobile browser 　　　　desired_caps['app'] = 'Chrome' 　　　　# to connect to Appium server use RemoteWebDriver 　　　　# and pass desired capabilities 　　　　self.driver = \
　webdriver.Remote("http://127.0.0.1:4723/wd/hub", desired_caps) 　　　　self.driver.get("http://demo.magentocommerce.com/") 　　　　self.driver.implicitly_wait(30) 　　def test_search_by_category(self): 　　　　# click on search icon 　　　　self.driver.find_element_by_xpath 　　　　　("//a[@href='#header-search']").click() 　　　　# get the search textbox 　　　　self.search_field = self.driver.find_element_by_name("q")
　self.search_field.clear() 　　　　# enter search keyword and submit 　　　　self.search_field.send_keys("phones") 　　　　self.search_field.submit() 　　　　# get all the anchor elements which have product names 　　　　# displayed currently on result page using 　　　　# find_elements_by_xpath method 　　　　products = self.driver\ 　　　　　.find_elements_by_xpath 　　　　　　("//div[@class='
category-products']/ul/li") 　　　　# check count of products shown in results 　　　　self.assertEqual(2, len(products)) 　　def tearDown(self): 　　　　# close the browser window 　　　　self.driver.quit() if __name__ == '__main__': 　　unittest.main(verbosity=2)
drag_and_drop(source, target)鼠标拖动source:鼠标拖动的源元素。target:鼠标释放的目标元素drag_and_drop(img, canvas)key_down(value, element=None)仅按下某个键，而不释放。这个方法用于修饰键（如Ctrl、Alt与Shift键）key:指修饰键。Key的值在Keys类中定义。target：按键触发的目标元素，如果为None，则按键在当前鼠标聚焦的元素上触发key_down(Keys. SHIFT)\send_keys(‘n’)\ key_up(Keys.SHIFT)
key_up(value, element=None)用于释放修饰键key:指修饰键。Key的值在Keys类中定义。target：按键触发的目标元素，如果为None，则按键在当前鼠标聚焦的元素上触发move_to_element(to_element)将鼠标移动至指定元素的中央to_element:指定的元素move_to_element(gmail_link)perform()提交（重放）已保存的动作perform()release(on_element=None)释放鼠标on_element:被鼠标释放的元素release(banner_img
send_keys(keys_to_send)对当前焦点元素的键盘操作keys_to_send:键盘的输入值send_keys(“hello”)send_keys_to_element(element, keys_to_send)对指定元素的键盘操作element:指定的元素。keys_to_send:键盘的输入值send_keys_to_element(firstName, “John”)
这个简单的场景中，当我们按下Shift+N组合键时，label标签会改变颜色。代码如下。from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait  from selenium.webdriver.support import expected_conditions from selenium.webdriver.common.action_chains import ActionChains  from selenium.webdriver.common.keys import Keys import unittest class HotkeyTest(unittest.TestCase): 　　URL = "https://rawgit.com/jeresig/jquery.hotkeys/master/test-static-05.html" 　　def setUp(self): 　　　　self.driver = webdriver.Chrome() 
　self.driver.get(self.URL)  　　　　self.driver.implicitly_wait(30)  　　　　self.driver.maximize_window() 　　def test_hotkey(self):  　　　　driver = self.driver 　　　　shift_n_label = WebDriverWait(self.driver, 10).\  　　　　　　until(expected_conditions.visibility_of_element_  　　　　　　located((By.ID, "_shift_n"))) 　　　　ActionChains(driver).\  　　　　　　key_down(Keys.SHIFT).\  　　　　　　send_keys('n').\  　　　　　　key_up(Keys.SHIFT).perform() 　　　　self.assertEqual("rgba(12, 162, 255, 1)",  　　　　　　　　　　　　　shift_n_label.value_of_css_  　　　　　　　　　　　　　property("background-color")) 　　def tearDown(self):  　　　　self.driver.close() if　__name__ == "__main__":  　　 unittest.main(verbosity=2)
from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait  from selenium.webdriver.support import expected_conditions from selenium.webdriver.common.action_chains import ActionChains  import unittest  class ToolTipTest (unittest.TestCase):  　　def setUp(self): 　　　　self.driver = webdriver.Firefox()  　　　　self.driver.get("
http://jqueryui.com/tooltip/")  　　　　self.driver.implicitly_wait(30)  　　　　self.driver.maximize_window() 　　def test_tool_tip(self):  　　　　driver = self.driver 　　　　frame_elm = driver.find_element_by_class_name("demo-frame")  　　　　driver.switch_to.frame(frame_elm) 　　　　age_field = driver.find_element_by_id("age")  　　　　ActionChains(self.driver).move_to_element(age_field).perform() 　　　　tool_tip_elm = WebDriverWait(self.driver, 
10)\ 　　　　　　.until(expected_conditions.visibility_of_element_  　　　　　　located((By.CLASS_NAME, "ui-tooltip-content"))) 　　　　# verify tooltip message 　　　　self.assertEqual("We ask for your age only for statistical  　　　　purposes.", tool_tip_elm.text) 　　def tearDown(self):  　　　　self.driver.close() if __name__ == "__main__":  　　unittest.main(verbosity=2)
from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains  import unittest class DoubleClickTest (unittest.TestCase):  　　URL = "http://api.jquery.com/dblclick/" 　　def setUp(self): 　　　　self.driver = webdriver.Chrome()  　　　　self.driver.get(self.URL)  　　　　self.driver.maximize_window()
　def test_double_click(self):  　　　　driver = self.driver 　　　　frame = driver.find_element_by_tag_name("iframe")  　　　　driver.switch_to.frame(frame) 　　　　box = driver.find_element_by_tag_name("div") 　　　　# verify color is Blue  　　　　self.assertEqual("rgba(0, 0, 255, 1)", 　　　　　　　　　　　　　box.value_of_css_property("background-color")) 　　　　ActionChains(driver).move_to_element 　　　　　 ( driver.find_element_by_tag_name("span"))
\.perform() 　　　　ActionChains(driver).double_click(box).perform() 　　　　# verify Color is Yellow  　　　　self.assertEqual("rgba(255, 255, 0, 1)", 　　　　　　　　　　　　 box.value_of_css_property("background-color")) 　　def tearDown(self):  　　　　self.driver.close() if __name__ == "__main__":  　　unittest.main(verbosity=2)
from selenium import webdriver from selenium.webdriver.common.action_chains import ActionChains  import unittest  class DragAndDropTest (unittest.TestCase): 　　URL = "http://jqueryui.com/resources/ 　　　　　 demos/droppable/default.html" 　　def setUp(self): 　　　　self.driver = webdriver.Firefox()  　　　　self.driver.get(self.URL) 
　self.driver.maximize_window(30)  　　　　self.driver.maximize_window() 　　def test_drag_and_drop(self):  　　　　driver = self.driver 　　　　source = driver.find_element_by_id("draggable")  　　　　target = driver.find_element_by_id("droppable") 　　　　ActionChains(self.driver).drag_and_drop(source, target). perform() 　　　　self.assertEqual("Dropped!", target.text) 　　def tearDown(self):  　　　　self.driver.close() if __name__ == "__main__":  　　unittest.main(verbosity=2)
execute_async_script(script, *args)异步执行JS代码script:被执行的JS代码。 args:JS代码中的任意参数driver.execute_async_script("return document.title")execute_ script(script, *args)同步执行JS代码script:被执行的JS代码。 args:JS代码中的任意参数driver.execute_ script("return document.title")
from selenium import webdriver import unittest  class ExecuteJavaScriptTest (unittest.TestCase):  　　def setUp(self): 　　　　# create a new Firefox session  　　　　self.driver = webdriver.Firefox()  　　　　self.driver.implicitly_wait(30)  　　　　self.driver.maximize_window() 　　　　# navigate to the application home page 　　　　self.driver.get("
http://demo.magentocommerce.com/") 　　def test_search_by_category(self): 　　　　# get the search textbox 　　　　search_field = self.driver.find_element_by_name("q")  　　　　self.highlightElement(search_field)  　　　　search_field.clear() 　　　　# enter search keyword and submit  　　　　self.highlightElement(search_field) 　　　　search_field.send_keys("phones")  　　　　search_field.submit()
　　# get all the anchor elements which have product names 　　　　# displayed currently on result page using 　　　　# find_elements_by_xpath method 　　　　products = self.driver.find_elements_by_xpath("//h2[@ class='product-name']/a") 　　　　# check count of products shown in results  　　　　self.assertEqual(2, len(products)) 　　def tearDown(self): 　　　　# close the browser window  　　　　self.driver.quit() 　　def highlightElement(
self, element):  　　　　self.driver.execute_script("arguments[0].setAttribute('style',  　　　　arguments[1]);", 　　　　element, "color: green; 　　　　border: 2px solid green;")  　　　　self.driver.execute_script("arguments[0].setAttribute('style',  　　　　arguments[1]);", 　　　　element , "") if __name__ == "__main__":  　　unittest.main(verbosity=2)
def highlightElement(self, element):  　　　self.driver.execute_script("arguments[0].setAttribute('style',  　　　arguments[1]);", 　　　element, "color: green; border: 2px solid green;") 　　　self.driver.execute_script("arguments[0].setAttribute('style',  　　　arguments[1]);", 　　　element , "")
get_screenshot_as_png()获取当前屏幕截图的二进制文件数据driver.get_screenshot_as_png()
from selenium import webdriver  import datetime, time, unittest from selenium.common.exceptions import NoSuchElementException  class ScreenShotTest(unittest.TestCase):  　　def setUp(self): 　　　　self.driver = webdriver.Firefox()  　　　　self.driver.get("http://demo.magentocommerce.com/") 　　def test_screen_shot(self):  　　　　driver = self.driver 　　　　try: 　　　　　　promo_banner_elem = driver.find_element_by_id(
"promo_ banner") 　　　　　　self.assertEqual("Promotions", promo_banner_elem.text)  　　　　except NoSuchElementException: 　　　　　　st = datetime.datetime\ 　　　　　　　　.fromtimestamp(time.time()).strftime('%Y%m%d_%H%M%S')  　　　　　　file_name = "main_page_missing_banner" + st + ".png" 　　　　　　driver.save_screenshot(file_name) 　　　　　　raise 　　def tearDown(self):  　　　　self.driver.close() if __name__ == "__main__":  　　unittest.main(verbosity=2)
try: 　　promo_banner_elem = driver.find_element_by_id("promo_banner")  　　self.assertEqual("Promotions", promo_banner_elem.text) except NoSuchElementException: 　　st = datetime.datetime.fromtimestamp(time.time()). strftime('%Y%m%d_%H%M%S') 　　file_name = "main_page_missing_banner" + st + ".png" 　　driver.save_screenshot(file__name) 　　raise
当我们使用上述截屏方法时，推荐使用包含唯一标识（例如时间戳）的名称，并且保存为PNG图片等高压缩图片格式，来控制图片的大小。
结合之前章节我们设计过的测试脚本，添加屏幕录制功能，代码如下。import unittest from selenium import webdriver  from castro import Castro class SearchProductTest(unittest.TestCase):  　　def setUp(self): 　　　　# create an instance of Castro and provide name for the output 　　　　# file 　　　　self.screenCapture = Castro(filename="testSearchByCategory. swf") 　　　　# start the recording of movie  　　　　self.screenCapture.start() 　　　　# create a new Firefox session  　　　　self.driver = webdriver.Firefox()  　　　　self.driver.implicitly_wait(30)  　　　　self.driver.maximize_window() 　　　　# navigate to the application home page 
　self.driver.get("http://demo.magentocommerce.com/") 　　def test_search_by_category(self): 　　　　# get the search textbox 　　　　search_field = self.driver.find_element_by_name("q")  　　　　search_field.clear() 　　　　# enter search keyword and submit  　　　　search_field.send_keys("phones")  　　　　search_field.submit() 　　　　# get all the anchor elements which have product names 　　　　# displayed 　　　　# currently on 
result page using find_elements_by_xpath method 　　　　products = self.driver.find_elements_by_xpath("//h2[@  　　　　class='product-name']/a") 　　　　# check count of products shown in results  　　　　self.assertEqual(2, len(products)) 　　def tearDown(self): 　　　　# close the browser window  　　　　self.driver.quit() 　　　　# Stop the recording  　　　　self.screenCapture.stop() if __name__ == '__main__':  　　unittest.main(verbosity=2)
def setUp(self): 　　# Create an instance of Castro and provide name for the output 　　# file 　　self.screenCapture = Castro(filename="testSearchByCategory.swf") 　　# Start the recording of movie  　　self.screenCapture.start() 　　# create a new Firefox session  　　self.driver = webdriver.Firefox()  　　self.driver.implicitly_wait(30)  　　self.driver.maximize_window() 　　# navigate to the application home page  　　self.driver.get("http://demo.magentocommerce.com/")
在teadDown()部分，我们可以看到当完整的测试用例都执行完成后，调用stop()方法来停止屏幕录制。代码如下。def tearDown(self): 　　# close the browser window  　　self.driver.quit() 　　# Stop the recording  　　self.screenCapture.stop()
创建一个新的测试类PopupWindowTest，其中包括test_popup_window()方法，代码如下。from selenium import webdriver  import unittest class PopupWindowTest(unittest.TestCase): 　　URL = "https://rawgit.com/upgundecha/learnsewithpython/master/pages/Config.html" 　　def setUp(self)　　 : 　　　　self.driver = webdriver.Firefox() 　　　　self.driver.get(self.URL)  　　　　self.driver.maximize_window() 　　def test_popup_ window(self): 　　　　driver = self.driver
　# save the WindowHandle of Parent Browser Window  　　　　parent_window_id = driver.current_window_handle 　　　　# clicking Help Button will open Help Page in a new Popup 　　　　# Browser Window 　　　　help_button = driver.find_element_by_id("helpbutton")  　　　　help_button.click()  　　　　driver.switch_to.window("HelpWindow") 　　　　driver.close()  　　　　driver.switch_to.window(parent_window_id) 　　def tearDown(self):  　　　　self.driver.close()
在Context调用弹出窗口显示之前，我们先通过current_window_handle属性将父窗口的句柄信息保存下来（稍后我们将使用这个信息从弹出窗返回到父窗口）。接着使用WebDriver下的switch_to.window()方法获取弹出窗的名称或句柄信息，切换到我们要操作的那个弹出窗（子窗口）。下面我们演示通过名称定位弹出窗。driver.switch_to_window("HelpWindow")
from selenium.webdriver.support.ui import Select  class CookiesTest(unittest.TestCase):  　　def setUp(self): 　　　　# create a new Firefox session  　　　　self.driver = webdriver.Firefox()  　　　　self.driver.implicitly_wait(30)  　　　　self.driver.maximize_window() 　　　　# navigate to the application home page  　　　　self.driver.get("http://demo.magentocommerce.com/") 　　def test_store_cookie(self): 
　driver = self.driver 　　　　# get the Your language dropdown as instance of Select class  　　　　select_language = \ 　　　　　　Select(self.driver.find_element_by_id("select-language")) 　　　　# check default selected option is English  　　　　self.assertEqual("ENGLISH", select_language.first_selected_ option.text) 　　　　# store cookies should be none 　　　　store_cookie = driver.get_cookie("store")  　　　　self.assertEqual(None, store_cookie) 　　　　# select an option using select_by_visible 
text  　　　　select_language.select_by_visible_text("French") 　　　　# store cookie should be populated with selected country  　　　　store_cookie = driver.get_cookie("store")['value']  　　　　self.assertEqual("french", store_cookie) 　　def tearDown(self): 　　　　# close the browser window  　　　　self.driver.quit() if __name__ == '__main__':  　　unittest.main(verbosity=2)
除了unittest之外，Selenium WebDriver还可以集成很多其他的工具和框架。目前已经有很多基于Selenium WebDriver 实现的框架了。我们可以通过使Selenium WebDriver与现有的支持BDD（行为驱动开发）的框架结合起来，在自动化测试项目中实现BDD。还可以将Selenium Python API与持续集成（CI）工具、构建工具相集成，一旦应用程序开发完成就可以立即执行测试。这可以使开发人员对应用程序的质量和稳定性得到更早的反馈。
def test_my_account_link_is_displayed(self):  　　　　# get the Account link 　　　　account_link =  　　　　　self.driver.find_element_by_link_text("ACCOUNT")  　　　　# check My Account link is displayed/visible in  　　　　# the Home page footer  　　　　self.assertTrue(account_link.is_displayed())
import unittest from appium import webdriver class SearchProductsOnIPhone(unittest.TestCase): 　　SAUCE_USERNAME = 'upgundecha' 　　SUACE_KEY = 'c6e7132c-ae27-4217-b6fa-3cf7df0a7281' 　　def setUp(self): 　　　　desired_caps = {} 　　　　desired_caps['browserName'] = "Safari" 　　　　desired_caps['platformVersion'] = "7.1" 　　　　desired_caps['platformName'] = "iOS" 　　　　desired_caps['deviceName'] = "iPhone Simulator"
　sauce_string = self.SAUCE_USERNAME + ':' + self.SUACE_KEY 　　　　self.driver = \ 　　　　　　webdriver.Remote('http://' + sauce_string + 　　　　　　'@ondemand.saucelabs.com:80/wd/hub', desired_caps) 　　　　self.driver.get('http://demo.magentocommerce.com/') 　　　　self.driver.implicitly_wait(30) 　　　　self.driver.maximize_window() 　　def test_search_by_category(self): 　　　　# click on search icon 　　　　self.driver.find_
element_by_xpath("//a[@href= 　　　　'#header-search']").click() 　　　　# get the search textbox 　　　　self.search_field = self.driver.find_element_by_name("q") 　　　　self.search_field.clear() 　　　　# enter search keyword and submit 　　　　self.search_field.send_keys("phones") 　　　　self.search_field.submit() 　　　　# get all the anchor elements which have 　　　　# product names displayed 　　　　# currently on 
result page using 　　　　# find_elements_by_xpath method 　　　　products = self.driver\ 　　　　　　.find_elements_by_xpath 　　　　　　 ("//div[@class='category-products']/ul/li") 　　　　# check count of products shown in results 　　　　self.assertEqual(2, len(products)) 　　def tearDown(self): 　　　　# close the browser window 　　　　self.driver.quit() if __name__ == '__main__': 　　unittest.main(verbosity=2)